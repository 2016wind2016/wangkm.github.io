<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>wangkm&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="梦醒了，踏上心的旅程">
<meta property="og:type" content="website">
<meta property="og:title" content="wangkm&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="wangkm&#39;s blog">
<meta property="og:description" content="梦醒了，踏上心的旅程">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="wangkm&#39;s blog">
<meta name="twitter:description" content="梦醒了，踏上心的旅程">
  
    <link rel="alternate" href="/atom.xml" title="wangkm&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">wangkm&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-NodeJS基于Redis广播服的设计思路" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/20/NodeJS基于Redis广播服的设计思路/" class="article-date">
  <time datetime="2018-06-20T05:14:43.000Z" itemprop="datePublished">2018-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/20/NodeJS基于Redis广播服的设计思路/">NodeJS基于Redis广播服的设计思路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><pre><code>分布式集群是NodeJS游戏服务端一个基本要素，多进程间玩家通讯是游戏服的一个核心问题。目前常见的多进程广播数据的方式一种是通过RPC，另一种是Redis，本文主要讲通过使用Redis来实现。
</code></pre><h2 id="服务器设计基本原理"><a href="#服务器设计基本原理" class="headerlink" title="服务器设计基本原理"></a>服务器设计基本原理</h2><pre><code>1.广播服务器，只做登录、心跳、顶号、下线、广播数据基本逻辑功能。登录、心跳、顶号、下线是为了广播数据做辅助功能。
2.单纯广播服务器一般是为短连接主服务器服务的，长连接的主服务器除了做广播服还要做链接保持服，同样不做其它逻辑。
3.其它逻辑，比如向好友发信息，应交给逻辑服务器GameServer做。eg:逻辑服收到给好友发信息消息，判断完毕，具体向某个人广播时才向广播服指定人广播。
4.通过Redis的发布订阅方式，监听指定channel来实现。
</code></pre><h2 id="一个全服聊天服的设计思路"><a href="#一个全服聊天服的设计思路" class="headerlink" title="一个全服聊天服的设计思路"></a>一个全服聊天服的设计思路</h2><pre><code>1.Redis发布消息时应明确ServerID_ChanneelName,以缩小广播范围。
2.发布的消息应包含消息包名，已为了客户端做区分
3.单独向指定人广播的消息应指定目标人
4.设计一个ServerRoom的房间类，已Server为单位Redis订阅各自独立的ServerID_ChanneelName
5.玩家登陆后，查找自身ServerID对应的房间，若没有则需要创建并加入此房间。
6.每个聊天服需要订阅ChanneelName比如Notice以便做全服通知

eg:发布
向1001服的UID为1001@234, 1001@100的玩家聊天
ChanneelName：&quot;1001_Chat&quot;
{
    packageName: “fiend.chat”, //包名
    msg:&quot;你好a&quot;, //广播内容
    &quot;to&quot;:[1001@234, 1001@100]/&apos;all&apos;, //接收单个uid或多个UID数组,当为all时表示当前channel所有人
}
ChanneelName：&quot;Notice&quot;
{
    packageName: “notice.item”, //包名
    msg:&quot;你好a&quot;, //广播内容
}
eg:订阅
1.各个订阅ChanneelName：&quot;1001_Chat&quot;的聊天服收到订阅消息，根据to字段判断接收人群，再向目标人发送消息
2.各个订阅ChanneelName：&quot;Notice&quot;的聊天服,遍历所有ServerRoom向所有人广播
</code></pre><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><pre><code>比较仓促，还不会插入示意图，思路应该说清楚了，再具体还是文采匮乏啊！
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/20/NodeJS基于Redis广播服的设计思路/" data-id="cjimobeck0000ikvnc1j8oa4k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-基于Json的数据同步" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/14/基于Json的数据同步/" class="article-date">
  <time datetime="2018-06-14T02:22:54.000Z" itemprop="datePublished">2018-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/14/基于Json的数据同步/">基于Json的数据同步</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><pre><code>游戏服务器与客户端的数据同步，各家有各家的秘籍。下面我就分享一下http服务器和客户端基于JSON文件的数据同步的思路。
</code></pre><h2 id="何时同步"><a href="#何时同步" class="headerlink" title="何时同步"></a>何时同步</h2><pre><code>http短连接，就是每次返回客户端消息时，包同步数据带回去。同步数据放到消息返回前。
</code></pre><h2 id="Json文件制作和格式剖析"><a href="#Json文件制作和格式剖析" class="headerlink" title="Json文件制作和格式剖析"></a>Json文件制作和格式剖析</h2><pre><code>card.json
{
    TagName: card //此为json标识，前后端解析识别
    keys: [ //keys为Json具体数据键值
        {
            keyName: &apos;GUID&apos;,
            comment: &apos;唯一ID&apos;, //同步数据时用户标识此OBj，全局唯一
            type: &apos;String&apos;,
            value: &apos;&apos;
        },
        {
            keyName: &apos;uid&apos;, 
            comment: &apos;玩家UID&apos;, //基本说明，利于维护
            type: &apos;Number&apos;, //数据类型，可做基本校验
            value: 10000, //初始数据默认值,
        },
        {
            keyName: &apos;level&apos;,
            comment: &apos;等级&apos;,
            type: &apos;Number&apos;,
            value: 0
        },
        {
            keyName: &apos;ctSkin&apos;,
            comment: &apos;皮肤&apos;,
            type: &apos;Array&apos;,
            value: []
        }
    ]
}
</code></pre><h2 id="Json文件设计对应Obj格式"><a href="#Json文件设计对应Obj格式" class="headerlink" title="Json文件设计对应Obj格式"></a>Json文件设计对应Obj格式</h2><pre><code>简单描述下，JSON文件对应的Obj对象怎么设计
{
    tagName: card, //obj对应JSON文件名字
    keyIndex: { //同步时需要记录变更的数据位置，比直接传keyName要好
        GUID:0,
        uid：1,
        level: 2,
        ctSkin: 3,
    },
    keyValue: [&apos;10001@10000&apos;, 10000,  5, []] //本地保存，此OBj所有数据
    changeKeys: [2] //变更了那些Key
    function syncChangeToClient () {
        //简单的算法对应完毕
        [变更的JSON原型对应怎么解析，[[变更的位置，变更后数据格式]，[变更的位置，变更后数据格式]]，全局索引GUID（用来和多个卡牌做区分）]
        //卡牌&apos;10001@10000&apos;索引的对象，数据1位置变更为10
        return [&apos;card&apos;, [[1, 10]], &apos;10001@10000&apos;],
    }
    function syncToClient () {
        //简单的算法对应完毕
        [JSON原型名字，[当前所有数据]]
        return [&apos;card&apos;, [&apos;10001@10000&apos;, 10000,  5, []]],
    }
}
</code></pre><h2 id="同步的类型"><a href="#同步的类型" class="headerlink" title="同步的类型"></a>同步的类型</h2><pre><code>同步需要只要需要3个数据表示出，增加[1]、删除[2]、更新[3]
</code></pre><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><pre><code>这种增加，一般都是把新生成Obj全部同步给客户端。
eg:
{
    1:[ //数组，为了支持一次同步所有增加、删除、更新
        obj.syncToClient();//每一个增加的对象
        obj.syncToClient();//每一个增加的对象
        ...
    ]
}
</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre><code>删除Obj一般只需要提供tagName外加GUID即可
eg:
{
    2:[ //数组，为了支持一次同步所有增加、删除、更新
        [
           card，&apos;10001@10000&apos;
        ],
        ...
    ]
}
</code></pre><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><pre><code>更新需要提供tagName,GUID,以及每个更新的Key索引和最后的值
eg:
{
    3:[ //数组，为了支持一次同步所有增加、删除、更新
        obj.syncChangeToClient();//每一个更新的对象
        obj.syncChangeToClient();//每一个更新的对象
    ]
}
</code></pre><h2 id="同步的基础规则"><a href="#同步的基础规则" class="headerlink" title="同步的基础规则"></a>同步的基础规则</h2><pre><code>1.更新后删除的,数据不同步更新的字段，只同步删除
2.单个Obj多次更新的，每个Key只同步最后值，一次同步完毕
3.增加后更新的，只同步增加全部属性
4.增加后删除的，不同步数据
5.删除又增加的，理论不出现，但要同步增加的数据
6.增加、同步、删除各个key内有数据才有，比如只有增加同步只需key1就行,都有的话，就是{1：[]，2：[]，3：[]}
7.每次同步完毕都要清除本书数据变更状态
</code></pre><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><pre><code>思路还是比较乱，设计还是不是很成熟。终究是没有实际代码去验证，自己也很遗憾，等后续有成品东西出来，再接着验证去分享。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/14/基于Json的数据同步/" data-id="cjimobed20004ikvnfd87j07f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-调试九法-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/04/调试九法-笔记/" class="article-date">
  <time datetime="2018-06-04T01:41:55.000Z" itemprop="datePublished">2018-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/04/调试九法-笔记/">调试九法-笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><pre><code>软件开发者路线图看完以后，我开启了接下来的读书之路。一周时间准确的说是6天终于拿下这个山头。
废话不多说，这本书是一本从事编程行业一本经典书籍————依然不是一本工具书。它能指导我们如何快速的查找工作中的BUG，并把调试的规格简明扼要外加故事的手段归纳为九条规则。
</code></pre><h2 id="规则1-理解系统"><a href="#规则1-理解系统" class="headerlink" title="规则1 理解系统"></a>规则1 理解系统</h2><pre><code>通过阅读手册或者其它方式理解系统，能使我们避免很多低级的错误，并能对一些问题有一定的处理方式，以及帮助我们能更好的使用系统。
此规则又分为以下几个要点:
·阅读手册
·仔细阅读每个细节
·掌握基础知识
·了解工作流程
·了解工具
·查阅细节
</code></pre><h2 id="规则2-制造失败"><a href="#规则2-制造失败" class="headerlink" title="规则2 制造失败"></a>规则2 制造失败</h2><blockquote>
<p>“什么也比不上直接去的的证据来得重要。”————福尔摩斯，《血色的研究》</p>
</blockquote>
<pre><code>制造失败，能使我们观察错误，并专心的排查失败的原因，以及作为是否修复问题的依据。
此规则又分为以下几个要点:
·制造失败
·从头开始
·引发失败
·不模拟失败
·查找不受控制的条件
·仔细观察失败
·不过于相信统计数据
·不怀疑BUG发生的触发点
·保存好已经使用的调试工具
</code></pre><h2 id="规则3-不要想，而要看"><a href="#规则3-不要想，而要看" class="headerlink" title="规则3 不要想，而要看"></a>规则3 不要想，而要看</h2><blockquote>
<p>亲眼看到底层的失败是非常重要的。如果你猜测失败是如何发生的，那常常会修复一些根不是BUG的问题。这样的修复不仅不会解决问题，而且还会浪费时间和金钱，甚至会破坏其他地方。请记住，不要这样做。————选自本书</p>
</blockquote>
<pre><code>此规则又分为以下几个要点:
·观察失败
·查看细节
·对系统进行插装
·注意汉森堡不准原则
·勇于猜想，丹猜想只是为了确定搜索的重要目标
</code></pre><h2 id="规则4-分而治之"><a href="#规则4-分而治之" class="headerlink" title="规则4 分而治之"></a>规则4 分而治之</h2><pre><code>把问题分割处理，有力于快速定位失败产生的原因，节约时间。有序序列的二分法和顺序查找的效率对比。
此规则又分为以下几个要点:
·确定问题的查找范围
·逐步缩小搜索范围
·确定搜索范围内问题区域
·使用易于查看的测试模式
·从有问题的一端开始搜索
·修复已经发现的BUG
·首先消除特定类型的BUG
</code></pre><h2 id="规则5-一次只改一个地方"><a href="#规则5-一次只改一个地方" class="headerlink" title="规则5 一次只改一个地方"></a>规则5 一次只改一个地方</h2><pre><code>每次修改，只应修复和此次失败相关的部分。对于有代码重构症的人要忍住自己双手去修改BUG，完全遵守此规则很难，不过也有失之东隅收之桑榆。
此规则又分为以下几个要点:
·隔离关键因素
·明确问题点前不急于修改系统
·一次只改一个测试
·对比正常系统
·记录所作修改的问题点
</code></pre><h2 id="规则6-保持审计跟踪"><a href="#规则6-保持审计跟踪" class="headerlink" title="规则6 保持审计跟踪"></a>规则6 保持审计跟踪</h2><pre><code>对每次测试的条件和结果做记录和分类，有时会起到意想不到的效果。
此规则又分为以下几个要点:
·记录测试操作的流程、结果
·关注细节
·事件记录关联到一起
·利用设计的审计跟踪
·把事情记录下来
</code></pre><h2 id="规则7-检查插头"><a href="#规则7-检查插头" class="headerlink" title="规则7 检查插头"></a>规则7 检查插头</h2><blockquote>
<p>“没有什么比一个显而易见的事实更能迷惑人了。”————福尔摩斯，《博斯科姆比溪谷秘案》</p>
</blockquote>
<pre><code>显而易见的错误，往往灯下黑。
此规则又分为以下几个要点:
·质疑自己的假设
·从头开始检查
·对工具进行测试
</code></pre><h2 id="规则8-获得全新观点"><a href="#规则8-获得全新观点" class="headerlink" title="规则8 获得全新观点"></a>规则8 获得全新观点</h2><pre><code>一人计短两人技长，我们可以从其他人那边获取新的观点。
此规则又分为以下几个要点:
·帮助无处不在
·放下面子
·主动征求别人的意见
·报告症状，不要夹杂自己主观观点
·不缺的的判断，可以作为补充
</code></pre><h2 id="规则9-如果不修复BUG，它将依然存在"><a href="#规则9-如果不修复BUG，它将依然存在" class="headerlink" title="规则9 如果不修复BUG，它将依然存在"></a>规则9 如果不修复BUG，它将依然存在</h2><pre><code>我们的目标是解决BUG，而不是掩盖BUG。不明确BUG产生的原因，巧合的方式BUG被掩盖，BUG依然存在，会被再次触发。
此规则又分为以下几个要点:
·检查问题是够被修复
·查证自己的修改
·明确BUG从来不会自己消失
·从根本上解决问题
·对过程进行修复
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/04/调试九法-笔记/" data-id="cjimobecz0002ikvnq1s6c14d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-学习计划" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/30/学习计划/" class="article-date">
  <time datetime="2018-05-30T01:49:41.000Z" itemprop="datePublished">2018-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/30/学习计划/">学习计划</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><pre><code>近阶段的理想学习规划——千里之行，屎于足下
</code></pre><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><pre><code>1.读书 调试九法-软硬件错误排查之道 时间：7~9天
2.学习 ES标准内async/await,并能熟练应用到开发环境内 时间：3~5天
3.读书 TCP/IP网络编程 时间：15~20天
4.读书 操作系统――精髓与设计原理 时间：22~30天
5.读书 数据结构 时间：22~30天 （书籍加一些补充资料）
6.学习 Koa/Express...任意一种前端框架 时间：一个月左右 暂时无法估量
7.学习 掌握css一些基本语法 时间：7~10天
</code></pre><h2 id="目前状态"><a href="#目前状态" class="headerlink" title="目前状态"></a>目前状态</h2><h3 id="调试九法-软硬件错误排查之道"><a href="#调试九法-软硬件错误排查之道" class="headerlink" title="调试九法-软硬件错误排查之道"></a>调试九法-软硬件错误排查之道</h3><pre><code>2018.5.29 1-13页
2018.5.30 14-27页
2018.5.31 28-41页
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/30/学习计划/" data-id="cjimobecy0001ikvnn3kywp8g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-书籍目录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/30/书籍目录/" class="article-date">
  <time datetime="2018-05-30T01:33:45.000Z" itemprop="datePublished">2018-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/30/书籍目录/">书籍目录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><pre><code>记录读过的书，和即将读的书
</code></pre><h2 id="今年已读"><a href="#今年已读" class="headerlink" title="今年已读"></a>今年已读</h2><pre><code>深入浅出的NodeJS 朴灵 经典必读
ES6 标准入门(第三版) 阮一峰 入门必读
NodeJS实战 T.J 过时不推荐
软件开发者路线图：从学徒到高手 经典必读-尤其刚入行
</code></pre><h2 id="书架未读"><a href="#书架未读" class="headerlink" title="书架未读"></a>书架未读</h2><pre><code>操作系统――精髓与设计原理
数据结构 严蔚敏
TCP/IP网络编程 尹圣雨
</code></pre><h2 id="目前在读"><a href="#目前在读" class="headerlink" title="目前在读"></a>目前在读</h2><pre><code>调试九法-软硬件错误排查之道 David J.Agans
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/30/书籍目录/" data-id="cjimobed00003ikvnx0k6hnmu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-软件开发者路线图-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/25/软件开发者路线图-笔记/" class="article-date">
  <time datetime="2018-05-25T02:05:46.000Z" itemprop="datePublished">2018-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/25/软件开发者路线图-笔记/">软件开发者路线图-笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><pre><code>程序员，作为一个比较自律的技术工种，我是抱着怀疑的态度拿起了这本书——软件开发者都应读的书。工作之余，6天时间此书扫描一遍，此书还是干货不少的。
此书并不是一个工具书，按我之前的吐槽就是一行代码就没有，描述了很多模式——不是代码设计的模式，对于初入软件行业、以及从业多年的人都有独到的方式给予建议。
此书以工艺的角度把软件从业者分成学徒、熟练工、师傅三个阶段，并着重介绍了作为一位积极向上(财富/技术)的软件学徒阶段各种模式。
神奇的是，最终阐述现在我们不应该期望已经有了师傅级的软件工匠。
</code></pre><h2 id="空杯心态"><a href="#空杯心态" class="headerlink" title="空杯心态"></a>空杯心态</h2><pre><code>以大师和一个年轻的哲学家的故事阐明学徒期间的态度，不自满，拥抱与众不同的奇异想法，自己才能吸取更多。
空杯是把杯子做大，并持之以恒的填充各种含有H20的液体。
</code></pre><h3 id="白色腰带"><a href="#白色腰带" class="headerlink" title="白色腰带"></a>白色腰带</h3><pre><code>勇于放下技术包袱，系上白色腰带，努力学习学的知识。
</code></pre><h3 id="暴露无知"><a href="#暴露无知" class="headerlink" title="暴露无知"></a>暴露无知</h3><pre><code>每个人都有自己的擅长的领域，暴露无知并正视无知，可以让团队更加有效率的运行，同时来自团队的压力更能让你加速学习此技术的动力。
</code></pre><h3 id="以退为进"><a href="#以退为进" class="headerlink" title="以退为进"></a>以退为进</h3><blockquote>
<p>“众里寻他千百度，蓦然回首，那人却在灯火阑珊处。”眼着你蓦然回首时发现的模式向前推进，有时你就能想出新的东西了。 ——Robert Pirsig 《Zen and the Art if Motorcycle Maintenance》</p>
</blockquote>
<pre><code>没有相对应的技术储备，贸然迎难而上，头铁并不是一个好的选择，退到一个安全暴露无知、向同道中人寻求指导会大幅度的规避危险。
</code></pre><h2 id="走过漫漫长路"><a href="#走过漫漫长路" class="headerlink" title="走过漫漫长路"></a>走过漫漫长路</h2><blockquote>
<p>要在编程方面真正擅长需要医生的努力，还有不断学习实践的进取心。——Ron Jeffries等，《Extreme Programming Installed》</p>
</blockquote>
<pre><code>长路漫漫，如何坚持也许你能在这里找到答案
</code></pre><h3 id="坚守阵地"><a href="#坚守阵地" class="headerlink" title="坚守阵地"></a>坚守阵地</h3><pre><code>相对于管理，有些人更愿意在技术岗位了释放激情。
</code></pre><h2 id="准确的自我评估"><a href="#准确的自我评估" class="headerlink" title="准确的自我评估"></a>准确的自我评估</h2><pre><code>不要因为超过周围圈子的平均水平或者达到顶级水平，不要放弃释放激情。
采用只求最差在团队中不断打磨自己的技术；
达者可为师，找人指导来加速自己的成长；
同道中人、密切交往来人互通技术
</code></pre><h2 id="恒久学习"><a href="#恒久学习" class="headerlink" title="恒久学习"></a>恒久学习</h2><blockquote>
<p>如果我们放纵自己，我们将总是需要等待一些消遣或其他事情结束才能安心工作。只有那些对知识非常苛求，以至于在不利的环境下扔你能坚持探索的人才能取得更大的成就，从来就没有什么“有利条件”。——C.S.Lewis, “Learning in War-Time”，”The Weight of Glory”</p>
</blockquote>
<pre><code>技术工种不断学习是基本的要求
</code></pre><h3 id="分享所学"><a href="#分享所学" class="headerlink" title="分享所学"></a>分享所学</h3><pre><code>分享不会让你知识减少，会加速开发想法的交流，能够发现自己知识的漏洞，锤炼自己的技术以及刷新自己的技术评价。
</code></pre><h3 id="建立馈路"><a href="#建立馈路" class="headerlink" title="建立馈路"></a>建立馈路</h3><pre><code>客观高效的反馈，得到设计产品的质量，能够分析自身的能力。
</code></pre><h2 id="安排你的课程"><a href="#安排你的课程" class="headerlink" title="安排你的课程"></a>安排你的课程</h2><pre><code>合理的安排课程，我们才能更高效的学习
</code></pre><h3 id="阅读列表"><a href="#阅读列表" class="headerlink" title="阅读列表"></a>阅读列表</h3><pre><code>阅读列表能帮助我们查看自己学过什么，并对自己技术分类，对下一步安排有参考。分享他、查看别人的分享能够给予所有处于迷茫期的人帮助。
</code></pre><h3 id="坚持阅读"><a href="#坚持阅读" class="headerlink" title="坚持阅读"></a>坚持阅读</h3><pre><code>不积跬步无以至千里
一本整体概念阐述的书籍远比几个技术摘要重要。
</code></pre><h3 id="钻研名著"><a href="#钻研名著" class="headerlink" title="钻研名著"></a>钻研名著</h3><pre><code>只读读最优质的书，经典永不过时
</code></pre><h3 id="深入挖掘"><a href="#深入挖掘" class="headerlink" title="深入挖掘"></a>深入挖掘</h3><pre><code>深入挖掘了解原理，才能更加高效的开发，以及和靠巧合编程的人区分开来。
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>一篇博客下来，作为沉默寡言的程序员，原来自己文字表达能力更废。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/25/软件开发者路线图-笔记/" data-id="cjimobed30005ikvnzvfuhoyc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/06/20/NodeJS基于Redis广播服的设计思路/">NodeJS基于Redis广播服的设计思路</a>
          </li>
        
          <li>
            <a href="/2018/06/14/基于Json的数据同步/">基于Json的数据同步</a>
          </li>
        
          <li>
            <a href="/2018/06/04/调试九法-笔记/">调试九法-笔记</a>
          </li>
        
          <li>
            <a href="/2018/05/30/学习计划/">学习计划</a>
          </li>
        
          <li>
            <a href="/2018/05/30/书籍目录/">书籍目录</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 wangkm<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>