<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>wangkm&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="梦醒了，踏上心的旅程">
<meta property="og:type" content="website">
<meta property="og:title" content="wangkm&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="wangkm&#39;s blog">
<meta property="og:description" content="梦醒了，踏上心的旅程">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="wangkm&#39;s blog">
<meta name="twitter:description" content="梦醒了，踏上心的旅程">
  
    <link rel="alternate" href="/atom.xml" title="wangkm&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">wangkm&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-基于RPC的分布式广播服设计思路" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/06/基于RPC的分布式广播服设计思路/" class="article-date">
  <time datetime="2018-08-06T02:21:00.000Z" itemprop="datePublished">2018-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/06/基于RPC的分布式广播服设计思路/">基于RPC的分布式广播服设计思路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先前设计了一种基于Redis的分布式广播服，实际项目运行一段时间后，有几个问题需要面对</p>
<ol>
<li>整体依赖Redis整个广播服的压力受限于Redis的吞吐量。</li>
<li>因为项目主短连接的， 广播服需要承担一些长连接的逻辑，依赖Redis数据更新并不方便。</li>
<li>因为未进行聊天室拆分，人数N多时广播风暴不可避免</li>
<li>广播时基于Redis的发布订阅，玩家数据未标识玩家进程UID,进程多时数据交互效率不高</li>
</ol>
<p>本文主要讲针对上面几个问题重新设计的一个基于RPC的分布式广播服(纯理论，实际项目刚着手)。</p>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>需要几种类型服务器</p>
<ol>
<li>connecter 集群，保持和客户端的长连接，用于信息广播和一些交互的逻辑</li>
<li>chatRoomMgr 单点，聊天室拆分、合理的分散玩家到各个聊天室</li>
<li>master  单点，管理各个服务器进程的状态，记录和广播各个注册服务器的状态</li>
<li>gameserver 集群，http服务器，和客户端连接（已存在，显示说明为了解释方便）</li>
</ol>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>RPC基于webSocket，端口采用独立端口不和Clint连接的端口复用，用于服务端接口调用及维护服务器状态。</p>
<h3 id="master"><a href="#master" class="headerlink" title="master"></a>master</h3><ol>
<li>master服务器启动</li>
<li>非master进程启动时RPC向master注册自己服务器信息，以及取得其它注册服务器的信息。</li>
<li>非master进程，RPC连接其它注册服务器。</li>
<li>每个连接master的服务器，每30秒左右定时汇报自己服务器基本信息(可以夹带私货比如服务器人数，房间人数))。</li>
<li>非master进程状态变更，master服务器向所有注册到自己服务器广播启动、关闭等消息。</li>
<li>master提供接口用于RPC向此采集数据。</li>
</ol>
<h3 id="gameserver"><a href="#gameserver" class="headerlink" title="gameserver"></a>gameserver</h3><ol>
<li>启动，RPC连接各个进程</li>
<li>客户端http连接gameserver</li>
<li>gameserver通过RPC向connecter写入玩家的基本信息</li>
<li>gameserver返回一个connecter地址</li>
</ol>
<h3 id="connecter"><a href="#connecter" class="headerlink" title="connecter"></a>connecter</h3><ol>
<li>启动，RPC连接各个进程</li>
<li>客户端webSocket连接connecter</li>
<li>通用连接验证，connecter通过RPC向chatRoomMgr申请一个聊天室ID，并写入连接信息</li>
<li>connecter返回客户端聊天室ID</li>
<li>向master同步数据提供连接人数</li>
</ol>
<h3 id="chatRoomMgr"><a href="#chatRoomMgr" class="headerlink" title="chatRoomMgr"></a>chatRoomMgr</h3><ol>
<li>启动，RPC连接各个进程</li>
<li>启动聊天室功能，等待RPC请求创建聊天室，聊天室从1开始，每200人新增一个频道</li>
<li>聊天内容不入库，客户端可以缓存</li>
</ol>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><ul>
<li>聊天</li>
</ul>
<ol>
<li>客户端向聊天室发送消息</li>
<li>connecter接收消息</li>
<li>connecter向chatRoomMgr请求聊天消息</li>
<li>chatRoomMgr通过RPC向聊天室内各个玩家所在connector广播聊天消息</li>
</ol>
<ul>
<li>密集聊天（比较幼稚的思路）</li>
</ul>
<ol>
<li>每个聊天广播做个50条大小的数组，所有聊天消息先入数组</li>
<li>上次广播未推送完毕，等待广播</li>
<li>上次广播所有已推送完毕1秒左右，一次全部取出未广播的消息进行推送</li>
</ol>
<ul>
<li>系统广播</li>
</ul>
<ol>
<li>类似聊天室，但得消息缓存做一个优先原则</li>
<li>消息池总条数不变，若消息池已满优先级高的消息会挤优先级低的空间，相同优先级先到先得</li>
<li>直接由gameServer向各个connector广播系统消息</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一个常规的高仿Pomelo的分布式系统，全靠自己撸的话，开发设计难度不低，造轮子。chatRoomMgr单点的设计感觉不是很保险，应该从结构上想办法调整为可以集群。项目结构整体调整完毕再重发一版本说明吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/06/基于RPC的分布式广播服设计思路/" data-id="cjkhnhqp90003xcvnno4u53xy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-提问的智慧-读书笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/31/提问的智慧-读书笔记/" class="article-date">
  <time datetime="2018-07-31T02:24:24.000Z" itemprop="datePublished">2018-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/31/提问的智慧-读书笔记/">提问的智慧-读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一名光荣的程序猿，我们使用不同的开发工具来创建自己的世界。本文主要讲解当我们使用工具出现问题时出现问题时，我们应该如何高效的提问问题。</p>
<h2 id="在提问之前"><a href="#在提问之前" class="headerlink" title="在提问之前"></a>在提问之前</h2><blockquote>
<ol>
<li>尝试在你准备提问的论坛的旧文章中搜索答案。</li>
<li>尝试上网搜索以找到答案。</li>
<li>尝试阅读手册以找到答案。</li>
<li>尝试阅读常见问题文件（FAQ）以找到答案。</li>
<li>尝试自己检查或试验以找到答案</li>
<li>向你身边的强者朋友打听以找到答案。</li>
<li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li>
</ol>
</blockquote>
<p>提出问题前，我们应该利用自身能想到的方式去获得答案，毕竟每个人的时间都不是免费的，尊重别人即尊重自己。</p>
<h2 id="提问问题时"><a href="#提问问题时" class="headerlink" title="提问问题时"></a>提问问题时</h2><ol>
<li>确认需要反馈问题需要时，我们应该官方的论坛以及针对的模块。不要重复发帖以及技术论坛灌水以及做其它感觉很酷的事情，这样只会彰显自己不专业。</li>
<li>当某个项目提供开发者邮件列表时，应该使用项目邮件列表。</li>
<li>使用有意义且描述明确的标题，简洁且突出重点。</li>
<li>内容采用清晰、正确、精准并语法正确的语句，要明确问题点，以及发生条件。</li>
<li>使用易于读取且标准的文件格式，简化交流的难度。</li>
<li>态度要真诚。</li>
<li>问题解决后，加个简短的补充说明。首先对帮助的人表示感谢，然后给予关注或以后遭遇此问题的人提供帮助。</li>
</ol>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>发现问题后，高效解决问题的能力是成为技术大牛的必经之路。发现问题，提问的智慧，不仅是问的智慧，更多的是一个正确的提问和解决问题的流程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/31/提问的智慧-读书笔记/" data-id="cjkhnhqpf0007xcvnrde8iuzg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-玩家定时器模块的设计与实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/26/玩家定时器模块的设计与实现/" class="article-date">
  <time datetime="2018-07-26T04:51:35.000Z" itemprop="datePublished">2018-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/26/玩家定时器模块的设计与实现/">玩家定时器模块的设计与实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>游戏开发中，玩家一些定时刷新的物品、任务，若每个对象都增加一个setTimeout函数，数量就很恐怖了，尤其是玩家数量一多就更废了。本文针对这一现象，设计了一种线性定时器，它同时只有一个定时事件处于激活状态，当前定时事件处理完毕会启动下一个定时事件。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>玩家角色可以穿多件时装，时装又有时间限制，时装时间到期后，需要服务端把到期的时装卸下。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>为每个装扮增加一个定时器，到期时卸下装扮。<br>这就需要面对玩家有N个装扮，就需要同时启动N个定时器的问题。</p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>不做定时器，每次每次客户端请求一下，所有时装遍历一遍进行到期卸载的逻辑处理。<br>由于无脑遍历，付出的计算量和实现的功能相比，有点得不偿失，尤其是涉及到更多的定时时。</p>
<h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><p>做一个数组，数组内每个成员记录装扮ID和过期时间，并对时间从小到大排序。<br>装扮模块增加一个定时器，时间是数组第一个元素时间，时间到期卸载对应装扮，并pop指定此成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        SkinId:<span class="number">30001</span>,</span><br><span class="line">        endTime:<span class="number">1000000</span>,</span><br><span class="line">    &#125;，</span><br><span class="line">    &#123;</span><br><span class="line">        SkinId:<span class="number">30002</span>,</span><br><span class="line">        endTime:<span class="number">2000000</span>,</span><br><span class="line">    &#125;，</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>此方案单对装扮是比较完美，但仍不能避免玩家多种不同类型的定时事件，会同时启动多个定时器的问题。</p>
<h3 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h3><p>其实就是方案三的改良版，把设计一个定时器模块，此模块内部维护一个数组，数据内成员具有基本属性{type:事件类型，endTime:响应时间，id:目标ID…},数组内部依然对每个成员按响应事件按从下到大排序。</p>
<p>此方案实现了玩家身上，同时只有一个定时器模块响应的需求，同时又能高效的处理按时间监听的事件。</p>
<h2 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听类型</span></span><br><span class="line"><span class="keyword">const</span> LISTENER_TYPE = &#123;</span><br><span class="line">    APPEARANCE: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 生成监听</span></span><br><span class="line"><span class="comment"> * @param &#123;LISTENER_TYPE&#125; type</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; end_time</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; id //索引可以是对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NewListener</span>(<span class="params">type, end_time, id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type: type,</span><br><span class="line">        end_time: end_time,</span><br><span class="line">        id: id,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 增加监听</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; userData 玩家</span></span><br><span class="line"><span class="comment"> * @param &#123;NewListener&#125; listener</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AddListener</span>(<span class="params">userData, listener</span>) </span>&#123;</span><br><span class="line">    MF.Log.logDebug(<span class="string">'AddListener: '</span>, <span class="built_in">JSON</span>.stringify(listener));</span><br><span class="line">    <span class="keyword">if</span>(!userData.Timer) &#123;</span><br><span class="line">        userData.Timer = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(listener.end_time &lt;= <span class="number">0</span> || listener.type === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        MF.Log.logError(<span class="string">'AddListener: '</span>, <span class="built_in">JSON</span>.stringify(listener));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    userData.Timer.push(listener);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = userData.Timer.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(userData.Timer[i<span class="number">-1</span>].end_time &lt;= userData.Timer[i].end_time) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> tmp = userData.Timer[i];</span><br><span class="line">        userData.Timer[i] = userData.Timer[i<span class="number">-1</span>];</span><br><span class="line">        userData.Timer[i<span class="number">-1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 添加并踢出雷同的，更新序列</span></span><br><span class="line"><span class="comment"> * !!添加并向前排除相同的</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; userData 玩家</span></span><br><span class="line"><span class="comment"> * @param &#123;NewListener&#125; listener</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UpdateListener</span>(<span class="params">userData, listener</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!userData.Timer) &#123;</span><br><span class="line">        userData.Timer = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(listener.end_time &lt;= <span class="number">0</span> || listener.type === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        MF.Log.logError(<span class="string">'AddListener: '</span>, <span class="built_in">JSON</span>.stringify(listener));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    userData.Timer.push(listener);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = userData.Timer.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(userData.Timer[i<span class="number">-1</span>].type === listener.type &amp;&amp;</span><br><span class="line">            userData.Timer[i<span class="number">-1</span>].end_time !== listener.end_time &amp;&amp;</span><br><span class="line">            <span class="built_in">JSON</span>.stringify(userData.Timer[i<span class="number">-1</span>].id) === <span class="built_in">JSON</span>.stringify(listener.id)) &#123;</span><br><span class="line">            userData.Timer.splice(i<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">            i--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(userData.Timer[i<span class="number">-1</span>].end_time &lt;= userData.Timer[i].end_time) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> tmp = userData.Timer[i];</span><br><span class="line">        userData.Timer[i] = userData.Timer[i<span class="number">-1</span>];</span><br><span class="line">        userData.Timer[i<span class="number">-1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 运行</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; userData 玩家</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AutoRun</span>(<span class="params">userData</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> curTime = MF.Util.CurTimeStamp();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; userData.Timer.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> listener = userData.Timer[i];</span><br><span class="line">        <span class="keyword">if</span>(curTime &lt; listener.end_time) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        EndTimerEvent(userData, listener);</span><br><span class="line">        userData.Timer.splice(i, <span class="number">1</span>);</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 触发监听事件</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; userData 玩家</span></span><br><span class="line"><span class="comment"> * @param &#123;NewListener&#125; listener</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EndTimerEvent</span>(<span class="params">userData, listener</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> type = listener.type;</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> LISTENER_TYPE.APPEARANCE: &#123;</span><br><span class="line">            WW.Appearance.OnEndTimerEvent(userData, listener);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            MF.Log.logError(<span class="string">'Listener type not defined: '</span>, <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述是一个方案四的变种，AutoRun函数没有用定时器，因为项目中玩家数据是在Redis中存放的，所以在每次Redis取玩家数据后调用AutoRun函数。如果玩家数据在内存中可以自行改写AutoRun函数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/26/玩家定时器模块的设计与实现/" data-id="cjkhnhqpl000cxcvny44vjlo0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-游戏任务系统的设计(上)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/16/游戏任务系统的设计(上)/" class="article-date">
  <time datetime="2018-07-16T02:49:27.000Z" itemprop="datePublished">2018-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/16/游戏任务系统的设计(上)/">游戏任务系统的设计(上</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>忙忙碌碌地又一周过去了，又到了每周博客的时间了，这一周疲惫地推各种功能，没带脑子思考，又没心思用半天时间做一个新的功能探讨，终了翻了翻以前设计的功能，接下来就拿自己设计的任务系统做讲解了。</p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>任务系统需求有三种：</p>
<ul>
<li>每日任务：每个任务有独立的奖励，每日还有活跃度，活跃度可以兑换奖励，任务有次数限制，每日凌晨3点刷新，并清除活跃度。</li>
<li>周任务：周任务没有活跃度，除了个人奖励外，会增加公会积分，不可重复完成，每周一凌晨3点刷新。</li>
<li>成就：主要奖励成就点（用于显示玩家水平的一种方式），成就不可刷新。</li>
</ul>
<p>任务类型分类：</p>
<ul>
<li>聊天：世界频道发送**条信息 (日常)</li>
<li>战斗：扫荡**关卡次 (日常)</li>
<li>好友：添加**个好友 (日常)</li>
<li>战斗：进行世界Boss达到**名 (周常、成就)</li>
<li>登录：玩家累计登录**次数可完成 (日常、成就、周常)</li>
<li>卡牌：玩家培养**次卡牌 (日常)</li>
<li>卡牌：玩家拥有**张卡牌 (成就)</li>
<li>卡牌：玩家拥有**张X星卡牌 (成就)</li>
</ul>
<p>…我又不是策划就不一一枚举了</p>
<h2 id="功能提取"><a href="#功能提取" class="headerlink" title="功能提取"></a>功能提取</h2><ul>
<li>刷新处理</li>
<li>任务类型分类</li>
<li>任务分发</li>
<li>任务记录</li>
<li>任务触发</li>
<li>奖励发送</li>
<li>任务动态增加</li>
</ul>
<p>…仔细想想提取的又不是那个的有条理</p>
<h2 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h2><p>终于可以晒代码，水篇幅了，作为一个服务器端程序员，讲故事的确不是我所长。</p>
<h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><p>1、玩家每次登录时，上次刷新时间戳和当前时间做比较</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEnableRefresh</span>(<span class="params">lastTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hour5Time = <span class="built_in">Math</span>.floor(<span class="keyword">new</span> <span class="built_in">Date</span>().setHours(<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) / <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> ((lastTime &lt; hour5Time) &amp;&amp; ((lastTime &lt; hour5Time - <span class="number">86400</span>) || (utils.timestamp() &gt;= hour5Time)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2、系统每日3天发送刷新事件，每个在线玩家的任务刷新</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sysDailyRefresh</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nextTime = <span class="built_in">Math</span>.floor(<span class="keyword">new</span> <span class="built_in">Date</span>().setHours(<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) / <span class="number">1000</span>) + <span class="number">86400</span>;</span><br><span class="line">  <span class="keyword">let</span> seconds = nextTime - utils.timestamp();</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    userDailyRefresh();</span><br><span class="line">    sysDailyRefresh();</span><br><span class="line">  &#125;, seconds * <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3.周任务，需要判断判断再添加今日是否是周一即可</p>
<h3 id="任务类型分类"><a href="#任务类型分类" class="headerlink" title="任务类型分类"></a>任务类型分类</h3><p>仔细分各种任务类型，再一一枚举</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TASK_MODE = &#123;</span><br><span class="line">    FINISH_TASK: &#123;</span><br><span class="line">      ALL:            <span class="number">11</span>,  <span class="comment">//所有</span></span><br><span class="line">    &#125;,</span><br><span class="line">    RANDOM_CARD: &#123;</span><br><span class="line">      NUM:            <span class="number">21</span>,  <span class="comment">//召唤-累计召唤</span></span><br><span class="line">    &#125;,</span><br><span class="line">    BATTLE: &#123;</span><br><span class="line">      MAIN:           <span class="number">31</span>,  <span class="comment">//战斗-主线剧情</span></span><br><span class="line">      UNLIMITED:      <span class="number">32</span>,  <span class="comment">//战斗-无限模式</span></span><br><span class="line">      WORLD_BOSS:     <span class="number">33</span>,  <span class="comment">//战斗-世界Boss</span></span><br><span class="line">    &#125;,</span><br><span class="line">    FRIEND: &#123;</span><br><span class="line">      HAVE:           <span class="number">41</span>,  <span class="comment">//好友-拥有好友</span></span><br><span class="line">    &#125;,</span><br><span class="line">    CARD: &#123;</span><br><span class="line">      LEVEL_DEV:      <span class="number">51</span>,  <span class="comment">//卡牌-培养</span></span><br><span class="line">      LEVEL:          <span class="number">52</span>,  <span class="comment">//卡牌-等级</span></span><br><span class="line">      STAR:           <span class="number">53</span>,  <span class="comment">//卡牌-星级拥有</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再具体细分抽象可以为三类</p>
<ul>
<li>累计型：需要玩家手动触发的，每次响应累计+1，比如累计登陆、聊天次数</li>
<li>拥有型：总共拥有多少，比如拥有卡牌数量</li>
<li>排名型：达到多少名，因为和累计判断相反，故单独抽出来</li>
<li>ALL型：完成所有任务，这种一般针对日常任务</li>
</ul>
<h3 id="任务分发"><a href="#任务分发" class="headerlink" title="任务分发"></a>任务分发</h3><p>简单的采用玩家上线自动领取，毕竟是个坑钱的手游，那么任务触发的设计情怀。</p>
<h3 id="任务记录"><a href="#任务记录" class="headerlink" title="任务记录"></a>任务记录</h3><p>因为都是一些简单的任务，可以抽象成下面几个属性记录即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"type"</span> : <span class="number">0</span> <span class="comment">//日常、周常、成就</span></span><br><span class="line">    <span class="string">"mode"</span> : <span class="number">0</span> <span class="comment">//任务具体枚举类型</span></span><br><span class="line">    <span class="string">"cfgId"</span> : <span class="number">0</span> <span class="comment">//对应静态配置ID，用于查询具体</span></span><br><span class="line">    <span class="string">"num"</span> : <span class="number">0</span> <span class="comment">//任务需求数量、名次、等级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刷新、完成领取奖励后，直接删除即可。<br>任务完成的状态只有玩家领取任务奖励成功才出发。</p>
<h3 id="任务触发"><a href="#任务触发" class="headerlink" title="任务触发"></a>任务触发</h3><p>分为条件触发和登录触发两种方式</p>
<h4 id="登录触发"><a href="#登录触发" class="headerlink" title="登录触发"></a>登录触发</h4><p>顾名思义，玩家登录后，需要遍历玩家数据，后直接触发任务，主要应对拥有型任务。<br>eg:每次玩家上线，都要计算玩家卡组数量，并触发任务发送任务类型、以及卡牌数量。</p>
<h4 id="条件触发"><a href="#条件触发" class="headerlink" title="条件触发"></a>条件触发</h4><p>直接举例说明，每次玩家获得卡牌都要计算玩家卡组数量，并触发任务发送任务类型、以及卡牌数量。</p>
<p>其实条件触发基本上所有任务类型都可以截获，但登录触发如果没有的话手动修改数据、新增成就任务等都无法兼容，所以登录触发是有必要的，尤其是针对一次性的成就。</p>
<p>下面是具体针四种抽象的任务类型的响应</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 常规通用任务触发</span></span><br><span class="line"><span class="comment"> * 累计型</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; objTask 任务Obj</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; num 数量</span></span><br><span class="line"><span class="comment"> * @return &#123;Boolean&#125; 是否移除任务监听</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commonTrigger</span> (<span class="params">objTask, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isRemoveListener;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    isRemoveListener = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> tbObjTask = Config.getTbObjTask(objTask.getAttrInt(<span class="string">'type'</span>), objTask.getAttrInt(<span class="string">'cfgId'</span>));</span><br><span class="line">    <span class="keyword">if</span>(!tbObjTask) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> oldNum = objTask.getAttrInt(<span class="string">'num'</span>);</span><br><span class="line">    <span class="keyword">let</span> maxNum = tbObjTask[<span class="string">"num"</span>];</span><br><span class="line">    <span class="keyword">let</span> isMax = (oldNum + num) &gt;= maxNum;</span><br><span class="line">    <span class="keyword">let</span> newNum = isMax ? maxNum : (oldNum + num);</span><br><span class="line">    objTask.setAttrInt(<span class="string">'num'</span>, newNum);</span><br><span class="line">    isRemoveListener = isMax;</span><br><span class="line">  &#125; <span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> isRemoveListener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 常规通用任务触发</span></span><br><span class="line"><span class="comment"> * 拥有型</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; objTask 任务Obj</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; num 数量</span></span><br><span class="line"><span class="comment"> * @return &#123;Boolean&#125; 是否移除任务监听</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commonHaveTrigger</span> (<span class="params">objTask, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isRemoveListener;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tbObjTask = Config.getTbObjTask(objTask.getAttrInt(<span class="string">'type'</span>), objTask.getAttrInt(<span class="string">'cfgId'</span>));</span><br><span class="line">    <span class="keyword">if</span>(!tbObjTask) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> maxNum = tbObjTask[<span class="string">"num"</span>];</span><br><span class="line">    <span class="keyword">let</span> isMax = num &gt;= maxNum;</span><br><span class="line">    <span class="keyword">let</span> newNum = isMax ? maxNum : num;</span><br><span class="line">    objTask.setAttrInt(<span class="string">'num'</span>, newNum);</span><br><span class="line">    isRemoveListener = isMax;</span><br><span class="line">  &#125; <span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> isRemoveListener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 常规通用任务触发</span></span><br><span class="line"><span class="comment"> * 排名型</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; objTask 任务Obj</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; num 名次</span></span><br><span class="line"><span class="comment"> * @return &#123;Boolean&#125; 是否移除任务监听</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commonRankTrigger</span> (<span class="params">objTask, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isRemoveListener;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tbObjTask = Config.getTbObjTask(objTask.getAttrInt(<span class="string">'type'</span>), objTask.getAttrInt(<span class="string">'cfgId'</span>));</span><br><span class="line">    <span class="keyword">if</span>(!tbObjTask) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> maxNum = tbObjTask[<span class="string">"num"</span>];</span><br><span class="line">    <span class="keyword">let</span> isMax = num &lt;= maxNum;</span><br><span class="line">    <span class="keyword">let</span> newNum = isMax ? maxNum : num;</span><br><span class="line">    objTask.setAttrInt(<span class="string">'num'</span>, newNum);</span><br><span class="line">    isRemoveListener = isMax;</span><br><span class="line">  &#125; <span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> isRemoveListener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 常规通用任务触发</span></span><br><span class="line"><span class="comment"> * ALL型</span></span><br><span class="line"><span class="comment"> * ！此类型有外部任务种类统计任务剩余数量为0时会出发一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commonAll</span>(<span class="params">objTask, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isRemoveListener;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    isRemoveListener = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(objTask.getAttrInt(<span class="string">'type'</span>) !== type) &#123; <span class="comment">//类型相同则完成</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> tbObjTask = Config.getTbObjTask(objTask.getAttrInt(<span class="string">'type'</span>), objTask.getAttrInt(<span class="string">'cfgId'</span>));</span><br><span class="line">    <span class="keyword">if</span>(!tbObjTask) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> maxNum = tbObjTask[<span class="string">"num"</span>];</span><br><span class="line">    objTask.setAttrInt(maxNum);</span><br><span class="line">    isRemoveListener = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> isRemoveListener;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>时间准备的不够充足，先写到这里吧，下篇再具体讲解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/16/游戏任务系统的设计(上)/" data-id="cjkhnhqpi000axcvnyg9rvgka" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-使用消息字典做消息校验" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/09/使用消息字典做消息校验/" class="article-date">
  <time datetime="2018-07-09T02:06:53.000Z" itemprop="datePublished">2018-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/09/使用消息字典做消息校验/">使用消息字典做消息校验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于Http通信的游戏服务器和客户端一般首选JSON作为数据传输格式，通信参数校验是很琐碎的事。往往一些人为利用的BUG都与没有正确的参数校验，比如扣钱的参数传输负数等。人为做消息请求做参数校验又不能避免漏掉参数校验，我们需要一套行之有效的参数校验框架。本文主要讲如何利用做消息字典做消息检验。<br>下文主要以物品使用item_use消息做案例</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>通常的消息处理如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 物品使用</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; msg 消息体</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; msg.itemID 物品ID</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; msg.itemNum 物品数量</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; session 抽象连接对象</span></span><br><span class="line"><span class="comment"> * @param &#123;Function&#125; next 消息返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">item_use</span>(<span class="params">msg, session, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(msg.itemID === <span class="literal">undefined</span> || !<span class="built_in">Number</span>.isFinite(msg.itemID) || msg.itemID &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> next(&#123;<span class="attr">retCode</span>:<span class="string">'error param'</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(msg.itemNum === <span class="literal">undefined</span> || !<span class="built_in">Number</span>.isFinite(msg.itemNum) || msg.itemNum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> next(&#123;<span class="attr">retCode</span>:<span class="string">'error param'</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时参数还少，手写基本还OK，一旦参数10或者更多，相信你写这逻辑时，会吐的。</p>
<h2 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">msgCfg.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"comment"</span> : &#123;</span><br><span class="line">    <span class="attr">"消息名"</span> : &#123;</span><br><span class="line">      <span class="attr">"comment"</span> : <span class="string">"备注"</span>,</span><br><span class="line">      <span class="attr">"param"</span> : &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"val"</span> : &#123;</span><br><span class="line">    <span class="attr">"item_use"</span> : &#123;</span><br><span class="line">      <span class="attr">"comment"</span> : <span class="string">"物品使用"</span>,</span><br><span class="line">      <span class="attr">"param"</span> : &#123;</span><br><span class="line">        <span class="attr">"itemID"</span> : &#123;</span><br><span class="line">          <span class="attr">"type"</span> : <span class="string">"Number"</span>,</span><br><span class="line">          <span class="attr">"comment"</span> : <span class="string">"物品ID"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"itemNum"</span> : &#123;</span><br><span class="line">          <span class="attr">"type"</span> : <span class="string">"Number"</span>,</span><br><span class="line">          <span class="attr">"comment"</span> : <span class="string">"物品数量"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个JSON文件msgCfg.json作为消息字典，并在其中添加物品使用的消息，格式类似如上。写一个消息管理模块MsgMng.js，在消息收到和功能处理前进行参数校验（！不是在item_use内，是item_use调用前），基本逻辑如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MsgMng</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.msgParam = <span class="built_in">require</span>(<span class="string">'msgCfg.json'</span>).val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 参数校验</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; route</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; msg</span></span><br><span class="line"><span class="comment"> * @return &#123;null | Number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MsgMng.prototype.paramCheck = <span class="function"><span class="keyword">function</span> (<span class="params">route, msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> err = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> param = <span class="keyword">this</span>.msgParam[route];</span><br><span class="line">    <span class="keyword">if</span>(!param) &#123;</span><br><span class="line">      logger.info(<span class="string">"msg: "</span> + route + <span class="string">" not register"</span>);</span><br><span class="line">      err = RetCode.HTTP_CODE_401;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> param) &#123;</span><br><span class="line">      <span class="keyword">let</span> key = <span class="string">''</span> + k;</span><br><span class="line">      <span class="keyword">let</span> type = param[key][<span class="string">"type"</span>];</span><br><span class="line">      <span class="keyword">let</span> value = msg[key];</span><br><span class="line">      <span class="keyword">if</span>(value === <span class="literal">undefined</span> || value === <span class="literal">null</span> || type !== value.constructor.name || (value.constructor === <span class="built_in">Number</span> &amp;&amp; (value &lt; <span class="number">0</span> || !<span class="built_in">Number</span>.isFinite(value)))) &#123;</span><br><span class="line">        logger.info(<span class="string">"msg: "</span> + route + <span class="string">" param is:[%s], reqMsg is:[%s]"</span>, route, <span class="built_in">JSON</span>.stringify(param), <span class="built_in">JSON</span>.stringify(msg));</span><br><span class="line">        err = RetCode.ERROR_REQUEST_PARAM;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样新增消息只要在消息字典内配置好消息包名参数类型就能处理绝大多数参数校验的代码量了。</p>
<h2 id="继续深挖"><a href="#继续深挖" class="headerlink" title="继续深挖"></a>继续深挖</h2><p>消息字典的用途不止这个简单的作用</p>
<ul>
<li>前后端对应消息作为标准</li>
<li>消息功能和参数查询方便</li>
<li>模块交接减少难度</li>
<li>NX点直接做为消息生成模板</li>
<li>为每个参数配置测试模式值</li>
<li>可以自己改造，具体参数注册校验函数</li>
<li>自己想吧…</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不想盲婚哑嫁，消息字典应该是Http通讯必不可少的一部分。减少体力活，是一个合格的码农应该觉醒的意识。只有效率提升上去，才能搬更多的砖。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/09/使用消息字典做消息校验/" data-id="cjkhnhqpc0005xcvnkevsyfi8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-基于json格式的玩家数据兼容" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/02/基于json格式的玩家数据兼容/" class="article-date">
  <time datetime="2018-07-02T02:14:29.000Z" itemprop="datePublished">2018-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/02/基于json格式的玩家数据兼容/">基于json格式的玩家数据兼容</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>游戏开发中，玩家数据格式不是一成不变的，保证玩家数据格式变更后玩家上线后依然能够进行游戏是基本原则。<br>本文主要阐述数据库是Mysql时，以玩家表human为例子说明玩家数据兼容的一些方法。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`human`</span> (</span><br><span class="line">    <span class="string">`uid`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'玩家唯一ID'</span>,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'玩家名字'</span>,</span><br><span class="line">    <span class="string">`head`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">DEFAULT</span> <span class="string">'[1,1,3]'</span> <span class="keyword">COMMENT</span> <span class="string">'当前头像'</span>,</span><br><span class="line">    <span class="string">`exp`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'当前经验'</span>,</span><br><span class="line">    <span class="string">`level`</span> <span class="built_in">int</span>(<span class="number">3</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'当前等级'</span>,</span><br><span class="line">    <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">3</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'玩家年龄'</span>,</span><br><span class="line">    <span class="string">`gold`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'当前元宝数'</span>,</span><br><span class="line">    <span class="string">`diamond`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'当前钻石数量'</span>,</span><br><span class="line">    <span class="string">`VIP`</span> <span class="built_in">int</span>(<span class="number">2</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'VIP等级'</span>,</span><br><span class="line">    <span class="string">`ctGetSkin`</span> <span class="built_in">text</span> <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">COMMENT</span> <span class="string">'已获得不重复皮肤CfgId'</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`uid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_unicode_ci <span class="keyword">COMMENT</span>=<span class="string">'玩家基础信息'</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">human对象结构</span><br><span class="line">&#123;</span><br><span class="line">    uid:<span class="number">0</span>,</span><br><span class="line">    name:<span class="string">''</span>,</span><br><span class="line">    exp:<span class="number">0</span>,</span><br><span class="line">    level:<span class="number">0</span>，</span><br><span class="line">    age:<span class="number">0</span>,</span><br><span class="line">    gold:<span class="number">0</span>,</span><br><span class="line">    diamond:<span class="number">0</span>,</span><br><span class="line">    VIP:<span class="number">0</span>,</span><br><span class="line">    ctGetSkin:<span class="string">'&#123;&#125;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一、增删某个字段"><a href="#一、增删某个字段" class="headerlink" title="一、增删某个字段"></a>一、增删某个字段</h2><p>eg.策划需求变更，需要删除human.age字段<br>1.直接删除tb human.age字段<br>2.删除human实例化对象中age属性</p>
<h2 id="二、字段数据类型变更"><a href="#二、字段数据类型变更" class="headerlink" title="二、字段数据类型变更"></a>二、字段数据类型变更</h2><p>eg.uid从int类型转换为varchar<br>1.tb human.age字段类型能强转，直接转换<br>1.1 human实例化对象中uid属性调整为string</p>
<p>2.human中uid类型不能强转,uid字段可以变更<br>2.1 采用增删字段的解决方式</p>
<p>3.human中uid类型不能强转,uid字段不可以变更<br>3.1 新建字段内uid_1<br>3.2 写策略把uid值调整为目标格式，写到uid_1内<br>3.3 删除uid字段，uid_1字段重命名为uid</p>
<p>3.*的方式不推荐，操作复杂，容易出错。</p>
<h2 id="三、字段内数据内容格式变更"><a href="#三、字段内数据内容格式变更" class="headerlink" title="三、字段内数据内容格式变更"></a>三、字段内数据内容格式变更</h2><p>eg. ctGetSkin:’{id:{num},id:{num}}’ =&gt; ctGetSkin:’{id:{num, liftTime},id:{num, liftTime}}’<br>1.tb human.ctGetSkin 字段不变更<br>1.1 skin对象的添加lifeTime属性<br>1.2 调整ctGetSkin的解析方式,ctGetSkin = OnLoadCtGetSkin(reqly.ctGetSkin);</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CtGetSkin对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CtGetSkinDefault</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Skin对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SkinDefault</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        num:<span class="number">1</span>,</span><br><span class="line">        lifeTime:<span class="number">-1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象兼容解析</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObjCompatible</span>(<span class="params">tarObj, srcObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!srcObj) &#123;</span><br><span class="line">        <span class="keyword">return</span> tarObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> srcObj === <span class="string">'string'</span>)&#123;</span><br><span class="line">        srcObj = <span class="built_in">JSON</span>.parse(srcObj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> srcObj !== <span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> tarObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> tarObj)&#123;</span><br><span class="line">        <span class="keyword">let</span> k = i + <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">if</span>(srcObj[k] === <span class="literal">undefined</span> || srcObj[k] === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> tarObj[k] === <span class="string">'object'</span>) &#123;</span><br><span class="line">            ObjCompatible(tarObj[k], srcObj[k]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tarObj[k] = srcObj[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tarObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据解析容错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">OnLoadCtGetSkin</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = CtGetSkinDefault();</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> data === <span class="string">'string'</span>) &#123;</span><br><span class="line">        data = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> data !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//应该做一个属性递归判断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> ret) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[k] === <span class="literal">undefined</span> || data[k] === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret[k] = ObjCompatible(SkinDefault(), data[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h2><p>分析完上面三个场景解决方案，发现OnLoadCtGetSkin的这种方式可以通用。只要设计好一套的human解析方式，兼容问题代码方面基本不会出问题，所有关注点就在table调整上了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/02/基于json格式的玩家数据兼容/" data-id="cjkhnhqpb0004xcvnvxzdc74t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-NodeJS公会服的设计思路" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/25/NodeJS公会服的设计思路/" class="article-date">
  <time datetime="2018-06-25T01:55:34.000Z" itemprop="datePublished">2018-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/25/NodeJS公会服的设计思路/">NodeJS公会服的设计思路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>公会是游戏功能中玩家数据交互最为频繁的一个功能，如何让多个玩家操作同一份数据有序而不出错是个很值得非常重要的问题。NodeJS服务器由于无阻塞、单线程、异步、集群的特点使得此功能难点又增加N个百分点，本文分享自己单进程公会服的设计经验。</p>
<h2 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h2><ul>
<li>其它服务器和公会服交互</li>
<li>公会服如何承担访问压力</li>
<li>公会玩家基本信息同步问题</li>
<li>同一公会中会长A请求把会员C设为副会长和副会长B把会员C设为大队长，操作如何保证会员C最终职位为副会长，副会长B操作被否决。</li>
<li>公会A和公会B同时批准玩家C入会，如何保障先到先得，玩家C只在一个公会。</li>
</ul>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><ul>
<li>传统方式采用RPC方式,比如客户端GameServer访问需要修改公会数据</li>
<li>通过Redis发布订阅，比如一些广播请求</li>
</ul>
<h3 id="服务器压力"><a href="#服务器压力" class="headerlink" title="服务器压力"></a>服务器压力</h3><ul>
<li>公会服除内存存放数据外另外在Redis缓存维护一份供其它进程读取。</li>
<li>客户端不和公会服连接，所有操作都是通过GameServer转发</li>
<li>客户端对公会的查询操作，通过GameServer访问Redis即可</li>
<li>GameServer承担客户端消息的基本容错，只有存在修改数据时才访问公会服</li>
<li>公会成员、公会申请、公会操作日志等数据量较大的UI上做为子标签页打开访问</li>
</ul>
<h3 id="玩家信息同步问题"><a href="#玩家信息同步问题" class="headerlink" title="玩家信息同步问题"></a>玩家信息同步问题</h3><ul>
<li>创建公会成员数据对象，分别有姓名、等级、在线时间、公会ID、职位、入会时间、公会贡献等属性</li>
<li>没有申请、创建、加入公会的没有此对象，</li>
<li>创建公会成员不和公会对象直接绑定,公会只是公会成员的一个属性</li>
<li>玩家上下线同步此对象数据，如有特殊需求，可做策略比如每3小时同步一次数据</li>
</ul>
<h3 id="数据锁问题"><a href="#数据锁问题" class="headerlink" title="数据锁问题"></a>数据锁问题</h3><ul>
<li>每个公会对象和每个公会成员对象增加一个属性，标识是否为不可写状态</li>
<li>每个公会对象和每个公会成员对象增加一个消息队列，用来存放等待的请求</li>
<li>公会对象、公会成员对象为不可写状态时，数据访问需要等待直到状态解除</li>
<li>等待状态保护机制一定时间内不返回，请求当失败返回</li>
<li>修改公会加公会锁，修改玩家加玩家锁，同时修改时，需要同时加，访问也要等待所有状态解除</li>
</ul>
<h2 id="瓶颈"><a href="#瓶颈" class="headerlink" title="瓶颈"></a>瓶颈</h2><p>由于是采用单进程，虽然有策略分担了大部分压力，但终究对于大部分玩家都在操作工作时会出问题。所以，对公会的功能开发需要仔细考虑，比如公会功能放到一定等级才开放，公会部分操作设置冷却时间，部分功能可以考虑利用redis在其它进程实现。而这进一步，则需要的更加缜密的思维，以及天才般的想法。</p>
<h2 id="关于公会集群的想法"><a href="#关于公会集群的想法" class="headerlink" title="关于公会集群的想法"></a>关于公会集群的想法</h2><p>由于公会都有固定的ID，我们可以通过Hash算法使每次对公会的操作准确命中对应的进程。当然，肯定还有其它坑要踩，比如两个公会操作同一个玩家数据时，怎么对应。知识范围有限，还未有有效的方法。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>又到了说再见的时候了，此方案果然经不起仔细的推敲，知识掌握程度限制了对自己的思维能力。技术能力又使自己不能干脆的做出用C++或者GO语言实在公会服的设计决定。<br>总之，思路依然幼稚，贻笑大方了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/25/NodeJS公会服的设计思路/" data-id="cjkhnhqp80002xcvn67m2lydb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-NodeJS基于Redis广播服的设计思路" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/20/NodeJS基于Redis广播服的设计思路/" class="article-date">
  <time datetime="2018-06-20T05:14:43.000Z" itemprop="datePublished">2018-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/20/NodeJS基于Redis广播服的设计思路/">NodeJS基于Redis广播服的设计思路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>分布式集群是NodeJS游戏服务端一个基本要素，多进程间玩家通讯是游戏服的一个核心问题。目前常见的多进程广播数据的方式一种是通过RPC，另一种是Redis，本文主要讲通过使用Redis来实现。</p>
<h2 id="广播服设计基本规则"><a href="#广播服设计基本规则" class="headerlink" title="广播服设计基本规则"></a>广播服设计基本规则</h2><ul>
<li>广播服务器，只做登录、心跳、顶号、下线、广播数据基本逻辑功能。登录、心跳、顶号、下线是为了广播数据做辅助功能。</li>
<li>单纯广播服务器一般是为短连接主服务器服务的，长连接的主服务器除了做广播服还要做链接保持服，同样不做其它逻辑。</li>
<li>其它逻辑，比如向好友发信息，应交给逻辑服务器GameServer做。eg:逻辑服收到给好友发信息消息，判断完毕，具体向某个人广播时才向广播服指定人广播。</li>
<li>通过Redis的发布订阅方式，监听指定channel来实现。</li>
</ul>
<h2 id="一个全服广播服的设计思路"><a href="#一个全服广播服的设计思路" class="headerlink" title="一个全服广播服的设计思路"></a>一个全服广播服的设计思路</h2><ul>
<li>Redis发布消息时应明确ServerID_ChanneelName,以缩小广播范围。</li>
<li>发布的消息应包含消息包名，已为了客户端做区分</li>
<li>单独向指定人广播的消息应指定目标人</li>
<li>设计一个ServerRoom的房间类，已Server为单位Redis订阅各自独立的ServerID_ChanneelName</li>
<li>玩家登陆后，查找自身ServerID对应的房间，若没有则需要创建并加入此房间。</li>
<li>每个聊天服需要订阅ChanneelName比如Notice以便做全服通知</li>
</ul>
<p>eg:发布<br>向1001服的UID为1001@234, 1001@100的玩家聊天</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ChanneelName：<span class="string">"1001_Chat"</span></span><br><span class="line">&#123;</span><br><span class="line">    packageName: “fiend.chat”, <span class="comment">//包名</span></span><br><span class="line">    msg:<span class="string">"你好a"</span>, <span class="comment">//广播内容</span></span><br><span class="line">    <span class="string">"to"</span>:[<span class="number">1001</span>@<span class="number">234</span>, <span class="number">1001</span>@<span class="number">100</span>]/<span class="string">'all'</span>, <span class="comment">//接收单个uid或多个UID数组,当为all时表示当前channel所有人</span></span><br><span class="line">&#125;</span><br><span class="line">ChanneelName：<span class="string">"Notice"</span></span><br><span class="line">&#123;</span><br><span class="line">    packageName: “notice.item”, <span class="comment">//包名</span></span><br><span class="line">    msg:<span class="string">"你好a"</span>, <span class="comment">//广播内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eg:订阅<br>1.各个订阅ChanneelName：”1001_Chat”的聊天服收到订阅消息，根据to字段判断接收人群，再向目标人发送消息<br>2.各个订阅ChanneelName：”Notice”的聊天服,遍历所有ServerRoom向所有人广播</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>比较仓促，还不会插入示意图，思路应该说清楚了，再具体还是文采匮乏啊！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/20/NodeJS基于Redis广播服的设计思路/" data-id="cjkhnhqov0001xcvni06tzekz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-基于Json的数据同步" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/14/基于Json的数据同步/" class="article-date">
  <time datetime="2018-06-14T02:22:54.000Z" itemprop="datePublished">2018-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/14/基于Json的数据同步/">基于Json的数据同步</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>游戏服务器与客户端的数据同步，各家有各家的秘籍。下面我就分享一下http服务器和客户端基于JSON文件的数据同步的思路。</p>
<h2 id="何时同步"><a href="#何时同步" class="headerlink" title="何时同步"></a>何时同步</h2><p>http短连接，就是每次返回客户端消息时，包同步数据带回去。同步数据放到消息返回前。</p>
<h2 id="Json文件制作和格式剖析"><a href="#Json文件制作和格式剖析" class="headerlink" title="Json文件制作和格式剖析"></a>Json文件制作和格式剖析</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">card.json</span><br><span class="line">&#123;</span><br><span class="line">    TagName: card //此为json标识，前后端解析识别</span><br><span class="line">    keys: [ //keys为Json具体数据键值</span><br><span class="line">        &#123;</span><br><span class="line">            keyName: 'GUID',</span><br><span class="line">            comment: '唯一ID', //同步数据时用户标识此OBj，全局唯一</span><br><span class="line">            type: 'String',</span><br><span class="line">            value: ''</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            keyName: 'uid', </span><br><span class="line">            comment: '玩家UID', //基本说明，利于维护</span><br><span class="line">            type: 'Number', //数据类型，可做基本校验</span><br><span class="line">            value: 10000, //初始数据默认值,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            keyName: 'level',</span><br><span class="line">            comment: '等级',</span><br><span class="line">            type: 'Number',</span><br><span class="line">            value: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            keyName: 'ctSkin',</span><br><span class="line">            comment: '皮肤',</span><br><span class="line">            type: 'Array',</span><br><span class="line">            value: []</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Json文件设计对应Obj格式"><a href="#Json文件设计对应Obj格式" class="headerlink" title="Json文件设计对应Obj格式"></a>Json文件设计对应Obj格式</h2><p>简单描述下，JSON文件对应的Obj对象怎么设计</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tagName: card, <span class="comment">//obj对应JSON文件名字</span></span><br><span class="line">    keyIndex: &#123; <span class="comment">//同步时需要记录变更的数据位置，比直接传keyName要好</span></span><br><span class="line">        GUID:<span class="number">0</span>,</span><br><span class="line">        uid：<span class="number">1</span>,</span><br><span class="line">        level: <span class="number">2</span>,</span><br><span class="line">        ctSkin: <span class="number">3</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    keyValue: [<span class="string">'10001@10000'</span>, <span class="number">10000</span>,  <span class="number">5</span>, []] <span class="comment">//本地保存，此OBj所有数据</span></span><br><span class="line">    changeKeys: [<span class="number">2</span>] <span class="comment">//变更了那些Key</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">syncChangeToClient</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//简单的算法对应完毕</span></span><br><span class="line">        [变更的<span class="built_in">JSON</span>原型对应怎么解析，[[变更的位置，变更后数据格式]，[变更的位置，变更后数据格式]]，全局索引GUID（用来和多个卡牌做区分）]</span><br><span class="line">        <span class="comment">//卡牌'10001@10000'索引的对象，数据1位置变更为10</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'card'</span>, [[<span class="number">1</span>, <span class="number">10</span>]], <span class="string">'10001@10000'</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">syncToClient</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//简单的算法对应完毕</span></span><br><span class="line">        [<span class="built_in">JSON</span>原型名字，[当前所有数据]]</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'card'</span>, [<span class="string">'10001@10000'</span>, <span class="number">10000</span>,  <span class="number">5</span>, []]],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="同步的类型"><a href="#同步的类型" class="headerlink" title="同步的类型"></a>同步的类型</h2><p>同步需要只要需要3个数据表示出，增加[1]、删除[2]、更新[3]</p>
<h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>这种增加，一般都是把新生成Obj全部同步给客户端。<br>eg:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">1</span>:[ <span class="comment">//数组，为了支持一次同步所有增加、删除、更新</span></span><br><span class="line">        obj.syncToClient();<span class="comment">//每一个增加的对象</span></span><br><span class="line">        obj.syncToClient();<span class="comment">//每一个增加的对象</span></span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除Obj一般只需要提供tagName外加GUID即可<br>eg:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">2</span>:[ <span class="comment">//数组，为了支持一次同步所有增加、删除、更新</span></span><br><span class="line">        [</span><br><span class="line">            card，<span class="string">'10001@10000'</span></span><br><span class="line">        ],</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新需要提供tagName,GUID,以及每个更新的Key索引和最后的值<br>eg:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">3</span>:[ <span class="comment">//数组，为了支持一次同步所有增加、删除、更新</span></span><br><span class="line">        obj.syncChangeToClient();<span class="comment">//每一个更新的对象</span></span><br><span class="line">        obj.syncChangeToClient();<span class="comment">//每一个更新的对象</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="同步的基础规则"><a href="#同步的基础规则" class="headerlink" title="同步的基础规则"></a>同步的基础规则</h2><p>1.更新后删除的,数据不同步更新的字段，只同步删除<br>2.单个Obj多次更新的，每个Key只同步最后值，一次同步完毕<br>3.增加后更新的，只同步增加全部属性<br>4.增加后删除的，不同步数据<br>5.删除又增加的，理论不出现，但要同步增加的数据<br>6.增加、同步、删除各个key内有数据才有，比如只有增加同步只需key1就行,都有的话，就是{1：[]，2：[]，3：[]}<br>7.每次同步完毕都要清除本书数据变更状态</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>思路还是比较乱，设计还是不是很成熟。终究是没有实际代码去验证，自己也很遗憾，等后续有成品东西出来，再接着验证去分享。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/14/基于Json的数据同步/" data-id="cjkhnhqpg0008xcvnbhxin36d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-调试九法-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/04/调试九法-笔记/" class="article-date">
  <time datetime="2018-06-04T01:41:55.000Z" itemprop="datePublished">2018-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/04/调试九法-笔记/">调试九法-笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>软件开发者路线图看完以后，我开启了接下来的读书之路。一周时间准确的说是6天终于拿下这个山头。<br>废话不多说，这本书是一本从事编程行业一本经典书籍————依然不是一本工具书。它能指导我们如何快速的查找工作中的BUG，并把调试的规格简明扼要外加故事的手段归纳为九条规则。</p>
<h2 id="规则1-理解系统"><a href="#规则1-理解系统" class="headerlink" title="规则1 理解系统"></a>规则1 理解系统</h2><p>通过阅读手册或者其它方式理解系统，能使我们避免很多低级的错误，并能对一些问题有一定的处理方式，以及帮助我们能更好的使用系统。<br>此规则又分为以下几个要点:</p>
<ul>
<li>阅读手册</li>
<li>仔细阅读每个细节</li>
<li>掌握基础知识</li>
<li>了解工作流程</li>
<li>了解工具</li>
<li>查阅细节</li>
</ul>
<h2 id="规则2-制造失败"><a href="#规则2-制造失败" class="headerlink" title="规则2 制造失败"></a>规则2 制造失败</h2><blockquote>
<p>“什么也比不上直接去的的证据来得重要。”————福尔摩斯，《血色的研究》</p>
</blockquote>
<p>制造失败，能使我们观察错误，并专心的排查失败的原因，以及作为是否修复问题的依据。<br>此规则又分为以下几个要点:</p>
<ul>
<li>制造失败</li>
<li>从头开始</li>
<li>引发失败</li>
<li>不模拟失败</li>
<li>查找不受控制的条件</li>
<li>仔细观察失败</li>
<li>不过于相信统计数据</li>
<li>不怀疑BUG发生的触发点</li>
<li>保存好已经使用的调试工具</li>
</ul>
<h2 id="规则3-不要想，而要看"><a href="#规则3-不要想，而要看" class="headerlink" title="规则3 不要想，而要看"></a>规则3 不要想，而要看</h2><blockquote>
<p>亲眼看到底层的失败是非常重要的。如果你猜测失败是如何发生的，那常常会修复一些根不是BUG的问题。这样的修复不仅不会解决问题，而且还会浪费时间和金钱，甚至会破坏其他地方。请记住，不要这样做。————选自本书</p>
</blockquote>
<p>此规则又分为以下几个要点:</p>
<ul>
<li>观察失败</li>
<li>查看细节</li>
<li>对系统进行插装</li>
<li>注意汉森堡不准原则</li>
<li>勇于猜想，丹猜想只是为了确定搜索的重要目标</li>
</ul>
<h2 id="规则4-分而治之"><a href="#规则4-分而治之" class="headerlink" title="规则4 分而治之"></a>规则4 分而治之</h2><p>把问题分割处理，有力于快速定位失败产生的原因，节约时间。有序序列的二分法和顺序查找的效率对比。<br>此规则又分为以下几个要点:</p>
<ul>
<li>确定问题的查找范围</li>
<li>逐步缩小搜索范围</li>
<li>确定搜索范围内问题区域</li>
<li>使用易于查看的测试模式</li>
<li>从有问题的一端开始搜索</li>
<li>修复已经发现的BUG</li>
<li>首先消除特定类型的BUG</li>
</ul>
<h2 id="规则5-一次只改一个地方"><a href="#规则5-一次只改一个地方" class="headerlink" title="规则5 一次只改一个地方"></a>规则5 一次只改一个地方</h2><p>每次修改，只应修复和此次失败相关的部分。对于有代码重构症的人要忍住自己双手去修改BUG，完全遵守此规则很难，不过也有失之东隅收之桑榆。<br>此规则又分为以下几个要点:</p>
<ul>
<li>隔离关键因素</li>
<li>明确问题点前不急于修改系统</li>
<li>一次只改一个测试</li>
<li>对比正常系统</li>
<li>记录所作修改的问题点</li>
</ul>
<h2 id="规则6-保持审计跟踪"><a href="#规则6-保持审计跟踪" class="headerlink" title="规则6 保持审计跟踪"></a>规则6 保持审计跟踪</h2><p>对每次测试的条件和结果做记录和分类，有时会起到意想不到的效果。<br>此规则又分为以下几个要点:</p>
<ul>
<li>记录测试操作的流程、结果</li>
<li>关注细节</li>
<li>事件记录关联到一起</li>
<li>利用设计的审计跟踪</li>
<li>把事情记录下来</li>
</ul>
<h2 id="规则7-检查插头"><a href="#规则7-检查插头" class="headerlink" title="规则7 检查插头"></a>规则7 检查插头</h2><blockquote>
<p>“没有什么比一个显而易见的事实更能迷惑人了。”————福尔摩斯，《博斯科姆比溪谷秘案》</p>
</blockquote>
<p>显而易见的错误，往往灯下黑。<br>此规则又分为以下几个要点:</p>
<ul>
<li>质疑自己的假设</li>
<li>从头开始检查</li>
<li>对工具进行测试</li>
</ul>
<h2 id="规则8-获得全新观点"><a href="#规则8-获得全新观点" class="headerlink" title="规则8 获得全新观点"></a>规则8 获得全新观点</h2><p>一人计短两人技长，我们可以从其他人那边获取新的观点。<br>此规则又分为以下几个要点:</p>
<ul>
<li>帮助无处不在</li>
<li>放下面子</li>
<li>主动征求别人的意见</li>
<li>报告症状，不要夹杂自己主观观点</li>
<li>不缺的的判断，可以作为补充</li>
</ul>
<h2 id="规则9-如果不修复BUG，它将依然存在"><a href="#规则9-如果不修复BUG，它将依然存在" class="headerlink" title="规则9 如果不修复BUG，它将依然存在"></a>规则9 如果不修复BUG，它将依然存在</h2><p>我们的目标是解决BUG，而不是掩盖BUG。不明确BUG产生的原因，巧合的方式BUG被掩盖，BUG依然存在，会被再次触发。<br>此规则又分为以下几个要点:</p>
<ul>
<li>检查问题是够被修复</li>
<li>查证自己的修改</li>
<li>明确BUG从来不会自己消失</li>
<li>从根本上解决问题</li>
<li>对过程进行修复</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/04/调试九法-笔记/" data-id="cjkhnhqpk000bxcvn5sf4n3uf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/06/基于RPC的分布式广播服设计思路/">基于RPC的分布式广播服设计思路</a>
          </li>
        
          <li>
            <a href="/2018/07/31/提问的智慧-读书笔记/">提问的智慧-读书笔记</a>
          </li>
        
          <li>
            <a href="/2018/07/26/玩家定时器模块的设计与实现/">玩家定时器模块的设计与实现</a>
          </li>
        
          <li>
            <a href="/2018/07/16/游戏任务系统的设计(上)/">游戏任务系统的设计(上</a>
          </li>
        
          <li>
            <a href="/2018/07/09/使用消息字典做消息校验/">使用消息字典做消息校验</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 wangkm<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>